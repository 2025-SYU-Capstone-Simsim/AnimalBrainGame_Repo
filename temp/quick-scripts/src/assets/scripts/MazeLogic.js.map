{"version":3,"sources":["assets\\scripts\\MazeLogic.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["﻿// Learn TypeScript:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/typescript.html\n// Learn Attribute:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/reference/attributes.html\n// Learn life-cycle callbacks:\n//  - https://docs.cocos.com/creator/2.4/manual/en/scripting/life-cycle-callbacks.html\n\n// MazeLogic.ts\nexport default class MazeLogic {\n    private rows: number;\n    private cols: number;\n    private maze: number[][] = [];\n    public cellSize: number = 50;  // 각 셀은 50×50 픽셀\n\n    private container: cc.Graphics;\n\n    constructor(rows: number, cols: number, container: cc.Node) {\n        this.rows = rows;\n        this.cols = cols;\n        // container에 Graphics 컴포넌트가 없으면 추가합니다.\n        this.container = container.getComponent(cc.Graphics);\n        if (!this.container) {\n            this.container = container.addComponent(cc.Graphics);\n        }\n    }\n\n    generateMaze() {\n        // 전체를 벽(1)으로 채운 2차원 배열 생성\n        this.maze = Array.from({ length: this.rows }, () =>\n            Array(this.cols).fill(1)\n        );\n\n        const stack: { x: number; y: number }[] = [];\n        // 시작점을 (1, 1)로 지정 (홀수 그리드에서 안정적)\n        const startX = 1;\n        const startY = 1;\n        this.maze[startY][startX] = 0;\n        stack.push({ x: startX, y: startY });\n\n        while (stack.length > 0) {\n            const current = stack.pop()!;\n            const neighbors = this.getUnvisitedNeighbors(current.x, current.y);\n            if (neighbors.length > 0) {\n                stack.push(current);\n                const next = neighbors[Math.floor(Math.random() * neighbors.length)];\n                this.maze[next.y][next.x] = 0;\n                // 두 셀 사이의 벽(중간 셀) 제거\n                const wallX = (current.x + next.x) / 2;\n                const wallY = (current.y + next.y) / 2;\n                this.maze[wallY][wallX] = 0;\n                stack.push(next);\n            }\n        }\n    }\n\n    renderMaze() {\n        this.container.clear();\n\n        // 1. 전체 미로 영역을 \"오솔길\" 느낌의 색으로 채움 (예: 갈색)\n        const pathColor = cc.color(205, 133, 63);  // 갈색 계열 (Peru)\n        this.container.fillColor = pathColor;\n        this.container.rect(0, 0, this.cols * this.cellSize, this.rows * this.cellSize);\n        this.container.fill();\n\n        // 2. 벽(1)인 셀을 \"부쉬\" 느낌의 색으로 채움 (예: 진한 녹색)\n        const bushColor = cc.color(34, 139, 34);  // ForestGreen\n        for (let y = 0; y < this.rows; y++) {\n            for (let x = 0; x < this.cols; x++) {\n                if (this.maze[y][x] === 1) {\n                    this.container.fillColor = bushColor;\n                    this.container.rect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);\n                    this.container.fill();\n\n                    // 3. 각 벽 셀의 경계를 얇은 선으로 그림\n                    // 선 두께를 0.5로 설정해 보세요 (지원되지 않으면 1을 사용)\n                    this.container.lineWidth = 1;\n                    this.container.strokeColor = cc.Color.WHITE;\n                    const rx = x * this.cellSize;\n                    const ry = y * this.cellSize;\n                    const w = this.cellSize;\n                    const h = this.cellSize;\n                    this.container.moveTo(rx, ry);\n                    this.container.lineTo(rx + w, ry);\n                    this.container.lineTo(rx + w, ry + h);\n                    this.container.lineTo(rx, ry + h);\n                    this.container.lineTo(rx, ry);\n                    this.container.stroke();\n                }\n            }\n        }\n    }\n\n    getStartPosition() {\n        return { x: 1, y: 1 };\n    }\n\n    getGoalPosition() {\n        return { x: this.cols - 2, y: this.rows - 2 };\n    }\n\n    public isWalkable(cell: { x: number; y: number }): boolean {\n        if (cell.x < 0 || cell.x >= this.cols || cell.y < 0 || cell.y >= this.rows) {\n            return false;\n        }\n        return this.maze[cell.y][cell.x] === 0;\n    }\n\n    private getUnvisitedNeighbors(x: number, y: number): { x: number; y: number }[] {\n        const neighbors: { x: number; y: number }[] = [];\n        if (x > 1 && this.maze[y][x - 2] === 1) neighbors.push({ x: x - 2, y: y });\n        if (x < this.cols - 2 && this.maze[y][x + 2] === 1) neighbors.push({ x: x + 2, y: y });\n        if (y > 1 && this.maze[y - 2][x] === 1) neighbors.push({ x: x, y: y - 2 });\n        if (y < this.rows - 2 && this.maze[y + 2][x] === 1) neighbors.push({ x: x, y: y + 2 });\n        return neighbors;\n    }\n}"]}